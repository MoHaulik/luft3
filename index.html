<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Enhanced WebXR Breathing App</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <style>
    body { 
      margin: 0; 
      overflow: hidden;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    #overlay {
      position: absolute;
      top: 20px;
      left: 20px;
      color: white;
      z-index: 1;
      text-shadow: 1px 1px 3px rgba(0,0,0,0.7);
    }
    #start-button {
      padding: 12px 24px;
      font-size: 18px;
      background: rgba(72, 118, 255, 0.8);
      color: white;
      border: none;
      border-radius: 30px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
      cursor: pointer;
      transition: all 0.3s ease;
    }
    #start-button:hover {
      background: rgba(72, 118, 255, 1);
      transform: translateY(-2px);
      box-shadow: 0 6px 12px rgba(0,0,0,0.3);
    }
    #status {
      margin-top: 15px;
      font-size: 20px;
      background: rgba(0, 0, 0, 0.5);
      padding: 10px 15px;
      border-radius: 12px;
      display: none;
      backdrop-filter: blur(5px);
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      line-height: 1.5;
    }
    #breath-indicator {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      width: 200px;
      height: 40px;
      background: rgba(0, 0, 0, 0.5);
      border-radius: 20px;
      overflow: hidden;
      display: none;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }
    #breath-progress {
      height: 100%;
      width: 0%;
      background: linear-gradient(to right, #4876FF, #36D1DC);
      border-radius: 20px;
      transition: width 0.1s linear;
    }
  </style>
</head>
<body>
  <div id="overlay">
    <button id="start-button">Start AR Experience</button>
    <div id="status"></div>
  </div>
  <div id="breath-indicator">
    <div id="breath-progress"></div>
  </div>
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.150.1/build/three.module.js';
    import { ARButton } from 'https://unpkg.com/three@0.150.1/examples/jsm/webxr/ARButton.js';

    let camera, scene, renderer;
    let analyser, dataArray;
    let particles, particleMaterial;
    let breathSphere, glowMaterial;
    let clock = new THREE.Clock();
    let lastIntensity = 0;

    // Breathing session variables
    let phase = "breathing";
    let phaseStartTime = 0;
    const deepBreathingDuration = 30 * 6;    // total Deep Breathing phase: 180s
    const inhaleDuration = 6;               // 6s inhale
    const exhaleDuration = 6;               // 6s exhale
    const breathCycleDuration = inhaleDuration + exhaleDuration; // 12s per cycle
    const inhaleFraction = inhaleDuration / breathCycleDuration; // 0.5
    const holdDuration = 60;                // 60s hold
    const recoveryDuration = 15;            // 15s recovery
    let cycleCount = 0;
    const maxCycles = 3;

    let inhaleAudio, exhaleAudio, ambientAudio;
    let lastBreathStage = null;

    const particleCount = 1500;
    const particleRadius = 5;
    const particleSystem = {
      hueRange: [190, 260],
      baseSaturation: 0.7,
      baseSize: 0.3,
    };

    init();

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 50);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      renderer.setClearColor(0x000000, 0);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
      scene.add(ambientLight);

      const dirLight = new THREE.DirectionalLight(0xffffff, 1);
      dirLight.position.set(1,1,1);
      dirLight.castShadow = true;
      scene.add(dirLight);

      document.getElementById('start-button').addEventListener('click', () => {
        if (navigator.xr) {
          navigator.xr.isSessionSupported('immersive-ar').then(supported => {
            if (supported) {
              const sessionInit = {
                optionalFeatures: ['dom-overlay','light-estimation'],
                domOverlay: { root: document.body }
              };
              navigator.xr.requestSession('immersive-ar', sessionInit).then(onSessionStarted);
            } else {
              alert('AR not supported');
            }
          });
        } else alert('WebXR not supported');
      });
    }

    function onSessionStarted(session) {
      renderer.xr.setReferenceSpaceType('local');
      renderer.xr.setSession(session);
      document.getElementById('start-button').style.display = 'none';
      document.getElementById('status').style.display = 'block';
      document.getElementById('breath-indicator').style.display = 'block';

      phase = "breathing";
      phaseStartTime = clock.getElapsedTime();

      inhaleAudio = new Audio('inhale.mp3');
      exhaleAudio = new Audio('exhale.mp3');
      ambientAudio = new Audio('https://soundbible.com/mp3/ocean-waves-daniel_simon.mp3');
      ambientAudio.loop = true;
      ambientAudio.volume = 0.3;
      ambientAudio.play();

      navigator.mediaDevices.getUserMedia({audio:true,video:false})
        .then(stream => {
          const ctx = new (window.AudioContext||window.webkitAudioContext)();
          const src = ctx.createMediaStreamSource(stream);
          analyser = ctx.createAnalyser();
          analyser.fftSize = 256;
          analyser.smoothingTimeConstant = 0.6;
          dataArray = new Uint8Array(analyser.frequencyBinCount);
          src.connect(analyser);
        });

      renderer.setAnimationLoop(render);
      createParticles();
      createBreathingSphere();
    }

    function createBreathingSphere() {
      const geom = new THREE.SphereGeometry(0.5,32,32);
      const mat = new THREE.MeshPhongMaterial({
        color: 0x4876FF, transparent:true, opacity:0.6, shininess:100
      });
      breathSphere = new THREE.Mesh(geom, mat);
      breathSphere.position.set(0,0,-3);
      scene.add(breathSphere);

      const glowGeo = new THREE.SphereGeometry(0.55,32,32);
      glowMaterial = new THREE.ShaderMaterial({
        uniforms:{
          c:{value:0.5}, p:{value:3.0},
          glowColor:{value:new THREE.Color(0x00a1ff)},
          viewVector:{value:camera.position}
        },
        vertexShader:`
          uniform vec3 viewVector; uniform float c; uniform float p;
          varying float intensity;
          void main(){
            vec3 n = normalize(normal);
            vec3 v = normalize(viewVector);
            intensity = pow(c - dot(n,v), p);
            gl_Position = projectionMatrix*modelViewMatrix*vec4(position,1.0);
          }
        `,
        fragmentShader:`
          uniform vec3 glowColor; varying float intensity;
          void main(){
            gl_FragColor = vec4(glowColor * intensity, 1.0);
          }
        `,
        side:THREE.BackSide, blending:THREE.AdditiveBlending, transparent:true
      });
      const glowMesh = new THREE.Mesh(glowGeo, glowMaterial);
      glowMesh.position.copy(breathSphere.position);
      scene.add(glowMesh);
    }

    function createParticles(){
      const geo = new THREE.BufferGeometry();
      const pos=[], col=[], sz=[], al=[], turb=[], mult=[];

      for(let i=0;i<particleCount;i++){
        const θ = Math.random()*Math.PI*2;
        const φ = Math.acos(2*Math.random()-1);
        const r = Math.pow(Math.random(),0.7)*particleRadius;
        const x = r*Math.sin(φ)*Math.cos(θ),
              y = r*Math.sin(φ)*Math.sin(θ),
              z = r*Math.cos(φ)*0.7;
        pos.push(x,y,z);
        let c = new THREE.Color();
        const h = particleSystem.hueRange[0]+Math.random()*(particleSystem.hueRange[1]-particleSystem.hueRange[0]);
        c.setHSL(h/360, particleSystem.baseSaturation+Math.random()*0.3,0.5+Math.random()*0.5);
        col.push(c.r,c.g,c.b);
        sz.push(particleSystem.baseSize*(0.5+Math.random()));
        mult.push(0.8+Math.random()*1.5);
        al.push(0.2+Math.random()*0.8);
        turb.push(Math.random()*2);
      }

      geo.setAttribute('position', new THREE.Float32BufferAttribute(pos,3));
      geo.setAttribute('customColor', new THREE.Float32BufferAttribute(col,3));
      geo.setAttribute('size', new THREE.Float32BufferAttribute(sz,1));
      geo.setAttribute('sizeMultiplier', new THREE.Float32BufferAttribute(mult,1));
      geo.setAttribute('alpha', new THREE.Float32BufferAttribute(al,1));
      geo.setAttribute('turbulence', new THREE.Float32BufferAttribute(turb,1));

      particleMaterial = new THREE.ShaderMaterial({
        uniforms:{
          pointTexture:{ value:new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/spark1.png') },
          time:{value:0}, breathFactor:{value:0}, intensityFactor:{value:0}
        },
        vertexShader:`
          attribute float size, alpha, turbulence, sizeMultiplier;
          attribute vec3 customColor;
          varying vec3 vColor;
          varying float vAlpha;
          uniform float time, breathFactor, intensityFactor;
          void main(){
            vColor = customColor;
            vec3 p = position;
            float d = length(position.xy);
            float bf = breathFactor*(1.0-d/5.0)*1.5;
            p.z += bf;
            p.x += position.x*bf*0.2;
            p.y += position.y*bf*0.2;
            float tAmt = turbulence*0.3;
            p.x += sin(time*(0.5+turbulence)+position.z*2.0)*tAmt;
            p.y += cos(time*(0.7+turbulence)+position.x*2.0)*tAmt;
            p.z += sin(time*(0.9+turbulence)+position.y*2.0)*tAmt*0.5;
            if(d<3.0){
              p.z += intensityFactor*sin(time*2.0+d*3.0)*(3.0-d)*0.3;
            }
            vAlpha = alpha*(1.0-length(position)/5.0)*(0.6+0.4*intensityFactor);
            float szBoost = 1.0+intensityFactor*3.0*sizeMultiplier;
            float dynSize = size*szBoost;
            vec4 mv = modelViewMatrix*vec4(p,1.0);
            gl_PointSize = dynSize*(300.0/ -mv.z);
            gl_Position = projectionMatrix*mv;
          }
        `,
        fragmentShader:`
          uniform sampler2D pointTexture;
          varying vec3 vColor;
          varying float vAlpha;
          void main(){
            vec4 tex = texture2D(pointTexture, gl_PointCoord);
            gl_FragColor = vec4(vColor, vAlpha*tex.a);
            if(gl_FragColor.a<0.05) discard;
          }
        `,
        transparent:true, blending:THREE.AdditiveBlending, depthWrite:false
      });

      particles = new THREE.Points(geo, particleMaterial);
      particles.position.set(0,0,-3);
      scene.add(particles);
    }

    function updateParticles(bf, intensity){
      lastIntensity = lastIntensity*0.7 + intensity*0.3;
      particleMaterial.uniforms.time.value = clock.getElapsedTime();
      particleMaterial.uniforms.breathFactor.value = bf;
      particleMaterial.uniforms.intensityFactor.value = lastIntensity;
    }

    function render(){
      const dt = clock.getDelta();
      const t  = clock.getElapsedTime();
      let intensity = 0;
      if(analyser){
        analyser.getByteFrequencyData(dataArray);
        let sum=0,count=0;
        for(let i=2;i<20;i++){ sum += dataArray[i]*1.5; count++; }
        intensity = Math.min(1.0,(sum/count)/128);
        intensity = Math.pow(intensity,0.7);
      }

      let statusText = "", bf=0, progress=0;
      if(phase==="breathing"){
        const e = t - phaseStartTime;
        if(e >= deepBreathingDuration){
          phase="hold"; phaseStartTime = t;
        } else {
          const cycleEl = e % breathCycleDuration;
          progress = cycleEl / breathCycleDuration;
          const stage = (progress < inhaleFraction) ? "inhale" : "exhale";
          if(stage !== lastBreathStage){
            lastBreathStage = stage;
            (stage==="inhale" ? inhaleAudio : exhaleAudio).play();
          }
          bf = (0.7 + intensity*0.5) * Math.sin(2*Math.PI*(progress-0.25));
          updateParticles(bf, intensity);
          const scale = 0.5 + 0.4*(1+bf);
          breathSphere.scale.set(scale, scale, scale);
          glowMaterial.uniforms.glowColor.value.setHex(stage==="inhale" ? 0x00a1ff : 0x4876ff);
          const remMin = Math.floor((deepBreathingDuration - e)/60);
          const remSec = Math.floor((deepBreathingDuration - e)%60);
          statusText = `Phase: Deep Breathing<br>Remaining: ${remMin}:${remSec<10?'0':''}${remSec}`;
        }

      } else if(phase==="hold"){
        const e = t - phaseStartTime;
        if(e >= holdDuration){
          phase="recovery"; phaseStartTime = t;
        }
        bf = (0.2 + intensity*0.2)*Math.sin(2*Math.PI*(e/60));
        updateParticles(bf, intensity*0.8);
        const pulse = 0.2 + 0.05*Math.sin(e*0.5) + intensity*0.1;
        breathSphere.scale.set(pulse, pulse, pulse);
        glowMaterial.uniforms.glowColor.value.setHex(0x8a2be2);
        progress = e/holdDuration;
        statusText = `Phase: Breath Hold<br>Remaining: ${Math.floor(holdDuration - e)}s`;

      } else if(phase==="recovery"){
        const e = t - phaseStartTime;
        if(e >= recoveryDuration){
          cycleCount++;
          if(cycleCount < maxCycles){
            phase="breathing"; phaseStartTime = t;
          } else {
            renderer.setAnimationLoop(null);
            document.getElementById('status').innerHTML = "Session Finished!<br>Thank you!";
            document.getElementById('breath-indicator').style.display='none';
            const fade = setInterval(()=>{
              if(ambientAudio.volume > 0.05) ambientAudio.volume -= 0.05;
              else { ambientAudio.pause(); clearInterval(fade); }
            },200);
            return;
          }
        }
        const prog = e/recoveryDuration;
        bf = (0.6 + intensity*0.6)*((1-prog)-prog);
        updateParticles(bf, intensity*2.0);
        const recScale = 0.3 + 0.5*prog + intensity*0.2;
        breathSphere.scale.set(recScale, recScale, recScale);
        glowMaterial.uniforms.glowColor.value.setHex(0x00ffaa);
        progress = prog;
        statusText = `Phase: Recovery Breath<br>Take a deep breath...`;
      }

      document.getElementById('breath-progress').style.width = `${progress*100}%`;
      document.getElementById('status').innerHTML = `Cycle: ${cycleCount+1}/${maxCycles}<br>${statusText}`;

      particles.rotation.z += 0.01*dt;
      particles.rotation.y += 0.005*dt;
      glowMaterial.uniforms.viewVector.value = new THREE.Vector3().subVectors(camera.position, breathSphere.position);

      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
